
调用`wait`函数处理僵死子进程说明。

### 调用`wait`函数处理

代码：
- tcp_serv_3.cc 
- tcp_cli_3.cc 

##### 单独启动服务器

```c 
$ ps  -ao pid,ppid,tty,stat,command,wchan | grep tcp
38020 34206 ttys000  S+   ./tcp_serv_3     -

$ netstat -an | grep 9876
tcp4       0      0  *.9876                 *.*                    LISTEN
```

##### 启动客户端和服务器

```c 
$ netstat -an | grep 9876
tcp4       0      0  127.0.0.1.9876         127.0.0.1.62346        ESTABLISHED
tcp4       0      0  127.0.0.1.62346        127.0.0.1.9876         ESTABLISHED
tcp4       0      0  127.0.0.1.9876         127.0.0.1.62345        ESTABLISHED
tcp4       0      0  127.0.0.1.62345        127.0.0.1.9876         ESTABLISHED
tcp4       0      0  127.0.0.1.9876         127.0.0.1.62344        ESTABLISHED
tcp4       0      0  127.0.0.1.62344        127.0.0.1.9876         ESTABLISHED
tcp4       0      0  127.0.0.1.9876         127.0.0.1.62343        ESTABLISHED
tcp4       0      0  127.0.0.1.62343        127.0.0.1.9876         ESTABLISHED
tcp4       0      0  127.0.0.1.9876         127.0.0.1.62342        ESTABLISHED
tcp4       0      0  127.0.0.1.62342        127.0.0.1.9876         ESTABLISHED
tcp4       0      0  *.9876                 *.*                    LISTEN
```


```c 
ps  -ao pid,ppid,tty,stat,command,wchan | grep tcp
38020 34206 ttys000  S+   ./tcp_serv_3     -
38713 38020 ttys000  S+   ./tcp_serv_3     -
38714 38020 ttys000  S+   ./tcp_serv_3     -
38715 38020 ttys000  S+   ./tcp_serv_3     -
38716 38020 ttys000  S+   ./tcp_serv_3     -
38717 38020 ttys000  S+   ./tcp_serv_3     -
38712 38379 ttys002  S+   ./tcp_cli_3 127. -
```

##### 终止客户端

`Ctrl+D`终止客户端后，立此时立即执行`netstat`命令，会看到如下结果：
```c 
$ netstat -an | grep 9876
tcp4       0      0  *.9876                 *.*                    LISTEN
tcp4       0      0  127.0.0.1.62346        127.0.0.1.9876         TIME_WAIT
tcp4       0      0  127.0.0.1.62345        127.0.0.1.9876         TIME_WAIT
tcp4       0      0  127.0.0.1.62344        127.0.0.1.9876         TIME_WAIT
tcp4       0      0  127.0.0.1.62343        127.0.0.1.9876         TIME_WAIT
tcp4       0      0  127.0.0.1.62342        127.0.0.1.9876         TIME_WAIT
```
当前连接的客户端全部进入了`TIME_WAIT`状态，而监听服务器仍在等待客户连接。

一段时间后的`netstat`结果：
```c 
$ netstat -an | grep 9876
tcp4       0      0  *.9876                 *.*                    LISTEN
```

`ps`命令查看进程命令结果：
```c 
$ ps  -ao pid,ppid,tty,stat,command,wchan | grep tcp
38020 34206 ttys000  S+   ./tcp_serv_3     -
38713 38020 ttys000  Z+   (tcp_serv_3)     -
38714 38020 ttys000  Z+   (tcp_serv_3)     -
38715 38020 ttys000  Z+   (tcp_serv_3)     -
```

服务器通过`wait`函数来处理僵死的子进程，较之前少了2个子进程，但是仍然没有释放全部的僵死进程。

> 建立一个信号处理函数并在其中调用`wait`并不足以防止出现僵死进程。本问题在于：所有5个信号都在信号处理函数执行之前产生，而信号处理函数只执行一次，因为Unix信号一般是不排队都。更严重的是，本问题是不确定的。在刚刚运行的例子中，客户端与服务器在同一个主机上，信号处理函数执行1次，留下4个僵死进程。但如果在不同的主机上运行客户和服务器，那么信号处理函数一般执行两次，一次是第一个产生的信号引起的，由于另外4个信号在信号处理函数第一次执行时发生，因此该处理函数仅仅再被调用一次，从而留下3个僵死进程。有的时候，依赖于`FIN`到达服务器主机的时机，信号处理函数可能会执行3次甚至4次。

文中说明的会留下4个僵死进程，但是实际测试内容如上，僵死进程只有3个，当客户端连接数量从5改为10，僵死进程有7个。这个数量并不太可控。

**Linux的信号机制是不排队的，假如在某一时间段多个子进程推出后都会发出`SIGCHLD`信号，但父进程来不及一个一个地响应，所以父进程实际上只执行了一次信号处理函数。但执行一次信号处理函数只等待一个子进程退出，所有最后会有一些子进程仍然是僵尸进程。**